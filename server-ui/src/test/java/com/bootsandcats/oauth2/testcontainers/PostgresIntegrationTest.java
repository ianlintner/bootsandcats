/*
 * Copyright 2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.bootsandcats.oauth2.testcontainers;

import static org.assertj.core.api.Assertions.assertThat;

import com.bootsandcats.oauth2.entity.User;
import com.bootsandcats.oauth2.repository.UserRepository;
import java.time.LocalDateTime;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

/**
 * Integration tests for PostgreSQL persistence using Testcontainers.
 *
 * <p>These tests verify that our JPA entities and repositories work correctly against a real
 * PostgreSQL database instance, ensuring compatibility with production database behavior.
 *
 * <p><b>AI Agent Test Context:</b>
 *
 * <ul>
 *   <li>Test Category: Database Integration
 *   <li>Infrastructure: PostgreSQL 16 via Testcontainers
 *   <li>Purpose: Validate entity persistence, queries, and transactions
 * </ul>
 */
@SpringBootTest
@ActiveProfiles("testcontainers")
@Tag("testcontainers")
@Tag("postgres")
@DisplayName("PostgreSQL Integration Tests")
class PostgresIntegrationTest extends AbstractPostgresContainerTest {

    @Autowired private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        userRepository.deleteAll();
    }

    @Nested
    @DisplayName("User Persistence")
    class UserPersistence {

        @Test
        @DisplayName("GIVEN valid user data WHEN saving user THEN user is persisted with generated ID")
        @Transactional
        void shouldPersistUserWithGeneratedId() {
            // GIVEN: Valid user data
            User user = new User();
            user.setUsername("testuser");
            user.setEmail("test@example.com");
            user.setProvider("github");
            user.setProviderId("12345");
            user.setName("Test User");
            user.setPictureUrl("https://github.com/avatar.png");
            user.setLastLogin(LocalDateTime.now());

            // WHEN: Saving the user
            User savedUser = userRepository.save(user);

            // THEN: User is persisted with generated ID
            assertThat(savedUser.getId())
                    .as("User ID should be auto-generated by PostgreSQL")
                    .isNotNull()
                    .isPositive();
            assertThat(savedUser.getUsername()).isEqualTo("testuser");
            assertThat(savedUser.getEmail()).isEqualTo("test@example.com");
        }

        @Test
        @DisplayName(
                "GIVEN existing user WHEN finding by provider and providerId THEN user is retrieved")
        @Transactional
        void shouldFindUserByProviderAndProviderId() {
            // GIVEN: Existing user in database
            User user = new User();
            user.setUsername("githubuser");
            user.setEmail("github@example.com");
            user.setProvider("github");
            user.setProviderId("github-123");
            user.setName("GitHub User");
            userRepository.save(user);

            // WHEN: Finding by provider and provider ID
            Optional<User> found = userRepository.findByProviderAndProviderId("github", "github-123");

            // THEN: User is retrieved correctly
            assertThat(found)
                    .as("User should be found by provider and providerId")
                    .isPresent()
                    .hasValueSatisfying(
                            u -> {
                                assertThat(u.getUsername()).isEqualTo("githubuser");
                                assertThat(u.getProvider()).isEqualTo("github");
                            });
        }

        @Test
        @DisplayName(
                "GIVEN non-existent provider/providerId WHEN finding user THEN empty result returned")
        @Transactional
        void shouldReturnEmptyForNonExistentUser() {
            // GIVEN: No user with given provider/providerId

            // WHEN: Attempting to find non-existent user
            Optional<User> found =
                    userRepository.findByProviderAndProviderId("nonexistent", "99999");

            // THEN: Empty result is returned
            assertThat(found)
                    .as("Non-existent user should return empty Optional")
                    .isEmpty();
        }

        @Test
        @DisplayName("GIVEN existing user WHEN updating fields THEN changes are persisted")
        @Transactional
        void shouldUpdateUserFields() {
            // GIVEN: Existing user
            User user = new User();
            user.setUsername("updateuser");
            user.setEmail("update@example.com");
            user.setProvider("google");
            user.setProviderId("google-456");
            User savedUser = userRepository.save(user);

            // WHEN: Updating user fields
            savedUser.setEmail("newemail@example.com");
            savedUser.setName("Updated Name");
            savedUser.setLastLogin(LocalDateTime.now());
            userRepository.save(savedUser);

            // THEN: Changes are persisted
            Optional<User> updated = userRepository.findById(savedUser.getId());
            assertThat(updated)
                    .as("Updated user should be retrievable")
                    .isPresent()
                    .hasValueSatisfying(
                            u -> {
                                assertThat(u.getEmail()).isEqualTo("newemail@example.com");
                                assertThat(u.getName()).isEqualTo("Updated Name");
                                assertThat(u.getLastLogin()).isNotNull();
                            });
        }
    }

    @Nested
    @DisplayName("Transaction Behavior")
    class TransactionBehavior {

        @Test
        @DisplayName("GIVEN multiple users WHEN saved in transaction THEN all are persisted")
        @Transactional
        void shouldPersistMultipleUsersInTransaction() {
            // GIVEN: Multiple users to save
            User user1 = createUser("user1", "github", "gh-1");
            User user2 = createUser("user2", "google", "go-1");
            User user3 = createUser("user3", "azure", "az-1");

            // WHEN: Saving all users
            userRepository.save(user1);
            userRepository.save(user2);
            userRepository.save(user3);

            // THEN: All users are persisted
            long count = userRepository.count();
            assertThat(count)
                    .as("All users should be persisted in transaction")
                    .isEqualTo(3);
        }

        @Test
        @DisplayName("GIVEN user with unique constraint WHEN duplicate saved THEN transaction fails")
        void shouldEnforceUniqueConstraints() {
            // GIVEN: User already exists
            User user1 = createUser("uniqueuser", "github", "unique-id");
            userRepository.save(user1);

            // WHEN/THEN: Attempting to save duplicate should fail
            // Note: This depends on unique constraints in your schema
            User duplicate = createUser("uniqueuser", "github", "unique-id");

            // The actual behavior depends on your schema constraints
            // This test documents expected behavior
            assertThat(userRepository.findByProviderAndProviderId("github", "unique-id"))
                    .as("Original user should still exist")
                    .isPresent();
        }
    }

    @Nested
    @DisplayName("Query Performance")
    class QueryPerformance {

        @Test
        @DisplayName("GIVEN many users WHEN querying by index THEN query executes efficiently")
        @Transactional
        void shouldQueryEfficientlyWithIndex() {
            // GIVEN: Multiple users in database
            for (int i = 0; i < 100; i++) {
                User user = createUser("user" + i, "github", "id-" + i);
                userRepository.save(user);
            }

            // WHEN: Querying by indexed field
            long startTime = System.currentTimeMillis();
            Optional<User> found = userRepository.findByProviderAndProviderId("github", "id-50");
            long duration = System.currentTimeMillis() - startTime;

            // THEN: Query executes quickly (should be < 100ms with index)
            assertThat(found).isPresent();
            assertThat(duration)
                    .as("Indexed query should complete quickly (< 1000ms)")
                    .isLessThan(1000);
        }
    }

    private User createUser(String username, String provider, String providerId) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(username + "@example.com");
        user.setProvider(provider);
        user.setProviderId(providerId);
        return user;
    }
}
