apiVersion: v1
kind: ServiceAccount
metadata:
  name: secure-subdomain-oauth-sds-renderer
  namespace: aks-istio-ingress
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secure-subdomain-oauth-sds-renderer
  namespace: aks-istio-ingress
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch", "create", "update", "patch"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: secure-subdomain-oauth-sds-renderer
  namespace: aks-istio-ingress
subjects:
  - kind: ServiceAccount
    name: secure-subdomain-oauth-sds-renderer
    namespace: aks-istio-ingress
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: secure-subdomain-oauth-sds-renderer
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: secure-subdomain-oauth-sds-renderer
  namespace: aks-istio-ingress
spec:
  # Re-renders the SDS secret periodically so secret rotation in Key Vault propagates.
  schedule: "0 * * * *" # hourly
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 2
  jobTemplate:
    spec:
      backoffLimit: 1
      ttlSecondsAfterFinished: 300
      template:
        metadata:
          annotations:
            sidecar.istio.io/inject: "false"
        spec:
          serviceAccountName: secure-subdomain-oauth-sds-renderer
          restartPolicy: Never
          volumes:
            - name: secrets-store-inline
              csi:
                driver: secrets-store.csi.k8s.io
                readOnly: true
                volumeAttributes:
                  secretProviderClass: secure-subdomain-oauth-secrets-provider
          containers:
            - name: render
              # This job runs a shell script to render SDS files, so it needs a kubectl image that includes /bin/sh.
              # Use the project's ACR to avoid Docker Hub rate limits and ensure an ARM64-compatible image.
              image: gabby.azurecr.io/bitnami/kubectl:latest
              imagePullPolicy: IfNotPresent
              volumeMounts:
                - name: secrets-store-inline
                  mountPath: /mnt/secrets-store
                  readOnly: true
              command:
                - /bin/sh
                - -lc
                - |
                  set -eu
                  umask 077

                  sha256() {
                    if command -v sha256sum >/dev/null 2>&1; then
                      sha256sum | awk '{print $1}'
                    elif command -v shasum >/dev/null 2>&1; then
                      shasum -a 256 | awk '{print $1}'
                    else
                      openssl dgst -sha256 | awk '{print $2}'
                    fi
                  }

                  b64_nolf() {
                    base64 | tr -d '\n'
                  }

                  CLIENT_SECRET="$(cat /mnt/secrets-store/secure-subdomain-client-secret)"
                  HMAC_SECRET="$(cat /mnt/secrets-store/secure-subdomain-oauth-hmac-secret)"

                  CLIENT_SECRET_LEN="${#CLIENT_SECRET}"
                  HMAC_SECRET_LEN="${#HMAC_SECRET}"

                  CLIENT_SECRET_SHA="$(printf '%s' "$CLIENT_SECRET" | sha256)"
                  HMAC_SECRET_SHA="$(printf '%s' "$HMAC_SECRET" | sha256)"

                  CLIENT_SECRET_B64="$(printf '%s' "$CLIENT_SECRET" | b64_nolf)"
                  HMAC_SECRET_B64="$(printf '%s' "$HMAC_SECRET" | b64_nolf)"

                  echo "[sds-render] input client_secret len=${CLIENT_SECRET_LEN} sha256=${CLIENT_SECRET_SHA}"
                  echo "[sds-render] input hmac_secret  len=${HMAC_SECRET_LEN} sha256=${HMAC_SECRET_SHA}"

                  # If the Kubernetes Secret already matches the rendered values, do nothing.
                  # Envoy's file-based SDS does not reliably pick up secret changes without a restart,
                  # so we only restart the gateway when we actually changed the secret.
                  EXISTING_TOKEN_SECRET_SHA=""
                  EXISTING_HMAC_SECRET_SHA=""
                  if kubectl -n aks-istio-ingress get secret secure-subdomain-oauth-sds >/dev/null 2>&1; then
                    EXISTING_TOKEN_YAML_B64="$(kubectl -n aks-istio-ingress get secret secure-subdomain-oauth-sds -o jsonpath='{.data.secure-subdomain-oauth-token\.yaml}' || true)"
                    if [ -n "$EXISTING_TOKEN_YAML_B64" ]; then
                      EXISTING_TOKEN_INLINE_B64="$(printf '%s' "$EXISTING_TOKEN_YAML_B64" | base64 -d | awk '/inline_bytes:/{gsub(/\"/,"",$2); print $2; exit}')"
                      if [ -z "$EXISTING_TOKEN_INLINE_B64" ]; then
                        EXISTING_TOKEN_INLINE_STR="$(printf '%s' "$EXISTING_TOKEN_YAML_B64" | base64 -d | awk '/inline_string:/{sub(/.*inline_string:[[:space:]]*/,""); gsub(/\"/,""); print; exit}')"
                        if [ -n "$EXISTING_TOKEN_INLINE_STR" ]; then
                          EXISTING_TOKEN_INLINE_B64="$(printf '%s' "$EXISTING_TOKEN_INLINE_STR" | b64_nolf)"
                        fi
                      fi
                      if [ -n "$EXISTING_TOKEN_INLINE_B64" ]; then
                        EXISTING_TOKEN_SECRET_SHA="$(printf '%s' "$EXISTING_TOKEN_INLINE_B64" | base64 -d | sha256)"
                      fi
                    fi

                    EXISTING_HMAC_YAML_B64="$(kubectl -n aks-istio-ingress get secret secure-subdomain-oauth-sds -o jsonpath='{.data.secure-subdomain-oauth-hmac\.yaml}' || true)"
                    if [ -n "$EXISTING_HMAC_YAML_B64" ]; then
                      EXISTING_HMAC_INLINE_B64="$(printf '%s' "$EXISTING_HMAC_YAML_B64" | base64 -d | awk '/inline_bytes:/{gsub(/\"/,"",$2); print $2; exit}')"
                      if [ -z "$EXISTING_HMAC_INLINE_B64" ]; then
                        EXISTING_HMAC_INLINE_STR="$(printf '%s' "$EXISTING_HMAC_YAML_B64" | base64 -d | awk '/inline_string:/{sub(/.*inline_string:[[:space:]]*/,""); gsub(/\"/,""); print; exit}')"
                        if [ -n "$EXISTING_HMAC_INLINE_STR" ]; then
                          EXISTING_HMAC_INLINE_B64="$(printf '%s' "$EXISTING_HMAC_INLINE_STR" | b64_nolf)"
                        fi
                      fi
                      if [ -n "$EXISTING_HMAC_INLINE_B64" ]; then
                        EXISTING_HMAC_SECRET_SHA="$(printf '%s' "$EXISTING_HMAC_INLINE_B64" | base64 -d | sha256)"
                      fi
                    fi
                  fi

                  if [ -n "$EXISTING_TOKEN_SECRET_SHA" ] && [ -n "$EXISTING_HMAC_SECRET_SHA" ] \
                    && [ "$EXISTING_TOKEN_SECRET_SHA" = "$CLIENT_SECRET_SHA" ] \
                    && [ "$EXISTING_HMAC_SECRET_SHA" = "$HMAC_SECRET_SHA" ]; then
                    echo "[sds-render] secure-subdomain-oauth-sds already up to date; skipping secret apply and gateway restart"
                    exit 0
                  fi

                  # Write the SDS resources to temporary files.
                  cat > /tmp/secure-subdomain-oauth-token.yaml <<EOF
                  resources:
                  - "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret"
                    name: secure-subdomain-oauth-token
                    generic_secret:
                      secret:
                        inline_bytes: ${CLIENT_SECRET_B64}
                  EOF

                  cat > /tmp/secure-subdomain-oauth-hmac.yaml <<EOF
                  resources:
                  - "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret"
                    name: secure-subdomain-oauth-hmac
                    generic_secret:
                      secret:
                        inline_bytes: ${HMAC_SECRET_B64}
                  EOF

                  # Create/update the SDS secret. This must be mounted into the ingress gateway at /etc/istio/oauth2.
                  kubectl -n aks-istio-ingress create secret generic secure-subdomain-oauth-sds \
                    --from-file=secure-subdomain-oauth-token.yaml=/tmp/secure-subdomain-oauth-token.yaml \
                    --from-file=secure-subdomain-oauth-hmac.yaml=/tmp/secure-subdomain-oauth-hmac.yaml \
                    --dry-run=client -o yaml | kubectl apply -f -

                  echo "[sds-render] secure-subdomain-oauth-sds updated; restarting ingress gateway to pick up file-based SDS changes"
                  kubectl -n aks-istio-ingress rollout restart deployment/aks-istio-ingressgateway-external-asm-1-27

                  # Optional: verify the keys exist without printing secret values.
                  kubectl -n aks-istio-ingress get secret secure-subdomain-oauth-sds \
                    -o jsonpath='{.metadata.name} {.type} {.data.secure-subdomain-oauth-token\.yaml} {.data.secure-subdomain-oauth-hmac\.yaml}{"\n"}' >/dev/null
