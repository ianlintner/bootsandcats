apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: github-review-oauth2-exchange
  namespace: default
  labels:
    app.kubernetes.io/managed-by: kustomize
    project: bootsandcats
spec:
  workloadSelector:
    labels:
      app: github-review-service
  configPatches:
  - applyTo: CLUSTER
    match:
      context: ANY
    patch:
      operation: ADD
      value:
        name: oauth2_token_cluster_github_review
        type: STRICT_DNS
        connect_timeout: 5s
        lb_policy: ROUND_ROBIN
        http2_protocol_options: {}
        load_assignment:
          cluster_name: oauth2_token_cluster_github_review
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    address: oauth2-server.default.svc.cluster.local
                    port_value: 9000
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          defaultSourceCode:
            inlineString: |
              local OAUTH_HOST = "oauth2.cat-herding.net"
              local CLIENT_ID = "github-review-service"
              local COOKIE_NAME = "_ghreview_session"
              local COOKIE_MAX_AGE = 900
              -- Demo secret used by the sidecar during code exchange.
              -- Keep this in sync with the DB migration that seeds/updates the registered client.
              local CLIENT_SECRET = "demo-gh-review-client-secret"

              local function urlencode(str)
                if str == nil then return "" end
                return (str:gsub("([^%w_.%-~])", function(c)
                  return string.format("%%%02X", string.byte(c))
                end))
              end

              local function urldecode(str)
                if str == nil then return "" end
                return (str:gsub("%%(%x%x)", function(hex)
                  return string.char(tonumber(hex, 16))
                end):gsub("+", " "))
              end

              local b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
              local function base64url_decode(str)
                if str == nil then return nil end
                str = str:gsub('-', '+'):gsub('_', '/')
                local pad = #str % 4
                if pad > 0 then str = str .. string.rep('=', 4 - pad) end
                str = str:gsub('[^'..b64..'=]', '')
                return (str:gsub('.', function(x)
                  if x == '=' then return '' end
                  local r, f = '', (b64:find(x) - 1)
                  for i = 6, 1, -1 do r = r .. (f % 2^i - f % 2^(i-1) > 0 and '1' or '0') end
                  return r
                end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
                  if #x < 8 then return '' end
                  local c = 0
                  for i = 1, 8 do c = c + (x:sub(i, i) == '1' and 2^(8-i) or 0) end
                  return string.char(c)
                end))
              end

              local function parse_jwt_payload(token)
                if token == nil then return nil end
                local parts = {}
                for part in token:gmatch('[^.]+') do
                  table.insert(parts, part)
                end
                if #parts < 2 then return nil end
                return base64url_decode(parts[2])
              end

              local function json_get_claim(json_str, key)
                if json_str == nil then return nil end
                local pattern = '"' .. key .. '"%s*:%s*"([^"]*)"'
                local value = json_str:match(pattern)
                if value then return value end
                local array_pattern = '"' .. key .. '"%s*:%s*%[(.-)%]'
                local array_body = json_str:match(array_pattern)
                if array_body then
                  local items = {}
                  for v in array_body:gmatch('"([^"]*)"') do
                    table.insert(items, v)
                  end
                  return table.concat(items, " ")
                end
                return nil
              end

              local function parse_query(query)
                local params = {}
                if query == nil or query == "" then return params end
                for pair in query:gmatch("[^&]+") do
                  local key, value = pair:match("([^=]+)=?(.*)")
                  if key then
                    params[urldecode(key)] = urldecode(value or "")
                  end
                end
                return params
              end

              local function get_cookie(cookie_header, name)
                if cookie_header == nil then return nil end
                for cookie in cookie_header:gmatch("[^;]+") do
                  local trimmed = cookie:match("^%s*(.-)%s*$")
                  local k, v = trimmed:match("([^=]+)=(.*)")
                  if k and k == name then
                    return v
                  end
                end
                return nil
              end

              local function json_get_string(json_str, key)
                if json_str == nil then return nil end
                local pattern = '"' .. key .. '"%s*:%s*"([^"]*)"'
                return json_str:match(pattern)
              end

              local function is_public_path(path)
                return path:find("^/actuator") == 1
                    or path == "/favicon.ico"
                    or path:find("^/api/status") == 1
                    or path:find("^/public/") == 1
                    or path:find("^/css/") == 1
                    or path:find("^/js/") == 1
                    or path:find("^/images/") == 1
                    or path:find("^/webjars/") == 1
                    or path:find("^/swagger") == 1
                    or path:find("^/openapi") == 1
              end

              function envoy_on_request(request_handle)
                local headers = request_handle:headers()
                local path_with_query = headers:get(":path") or "/"
                local path_only = path_with_query:match("^([^?]+)") or "/"
                local query_string = path_with_query:match("%?(.+)$")
                local authority = headers:get(":authority") or "gh-review.cat-herding.net"
                local cookie_header = headers:get("cookie")

                if is_public_path(path_only) then
                  return
                end

                local session_token = get_cookie(cookie_header, COOKIE_NAME)
                if session_token ~= nil and session_token ~= "" then
                  local existing_auth = headers:get("authorization")
                  if existing_auth == nil then
                    headers:add("Authorization", "Bearer " .. session_token)
                  end
                  local payload_json = parse_jwt_payload(session_token)
                  if payload_json then
                    local sub = json_get_claim(payload_json, "sub")
                    if sub then headers:add("x-jwt-sub", sub) end
                    local username = json_get_claim(payload_json, "preferred_username")
                    if username then headers:add("x-jwt-username", username) end
                    local email = json_get_claim(payload_json, "email")
                    if email then headers:add("x-jwt-email", email) end
                    local name = json_get_claim(payload_json, "name")
                    if name then headers:add("x-jwt-name", name) end
                    local scope = json_get_claim(payload_json, "scope")
                    if scope then headers:add("x-jwt-scope", scope) end
                  end
                  return
                end

                local params = parse_query(query_string)
                local auth_code = params["code"]
                local state = params["state"]

                if auth_code ~= nil and auth_code ~= "" then
                  local redirect_uri = "https://" .. authority .. "/"
                  local token_body = "grant_type=authorization_code" ..
                    "&code=" .. urlencode(auth_code) ..
                    "&redirect_uri=" .. urlencode(redirect_uri) ..
                    "&client_id=" .. urlencode(CLIENT_ID)
                  if CLIENT_SECRET ~= nil and CLIENT_SECRET ~= "" then
                    token_body = token_body .. "&client_secret=" .. urlencode(CLIENT_SECRET)
                  end

                  local call_headers = {
                    [":method"] = "POST",
                    [":path"] = "/oauth2/token",
                    [":authority"] = "oauth2-server.default.svc.cluster.local",
                    ["content-type"] = "application/x-www-form-urlencoded",
                    ["accept"] = "application/json"
                  }

                  local resp_headers, resp_body = request_handle:httpCall(
                    "oauth2_token_cluster_github_review",
                    call_headers,
                    token_body,
                    5000,
                    false
                  )

                  if resp_headers then
                    local status = resp_headers[":status"]
                    if status == "200" and resp_body then
                      local access_token = json_get_string(resp_body, "access_token")
                      if access_token and access_token ~= "" then
                        local clean_path = "/"
                        if state and state ~= "" then
                          clean_path = urldecode(state)
                        end
                        local cookie = COOKIE_NAME .. "=" .. access_token ..
                          "; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=" .. COOKIE_MAX_AGE
                        request_handle:respond(
                          {[":status"] = "302", ["location"] = "https://" .. authority .. clean_path, ["set-cookie"] = cookie, ["cache-control"] = "no-store"},
                          ""
                        )
                        return
                      end
                    end
                  end

                  request_handle:respond(
                    {[":status"] = "401", ["content-type"] = "text/html"},
                    "<html><body><h1>Authentication Failed</h1><p><a href='/'>Try again</a></p></body></html>"
                  )
                  return
                end

                local redirect_uri = "https://" .. authority .. "/"
                local state_param = urlencode(path_with_query)

                local authorize_url = "https://" .. OAUTH_HOST .. "/oauth2/authorize" ..
                  "?response_type=code" ..
                  "&client_id=" .. urlencode(CLIENT_ID) ..
                  "&scope=" .. urlencode("openid profile email") ..
                  "&redirect_uri=" .. urlencode(redirect_uri) ..
                  "&state=" .. state_param

                request_handle:respond(
                  {[":status"] = "302", ["location"] = authorize_url, ["cache-control"] = "no-store"},
                  ""
                )
              end
