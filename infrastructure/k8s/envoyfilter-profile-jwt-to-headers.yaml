apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: profile-jwt-to-headers
  namespace: default
  labels:
    app.kubernetes.io/managed-by: kustomize
    project: bootsandcats
spec:
  # Applied at the profile-service sidecar to shape inbound traffic
  workloadSelector:
    labels:
      app: profile-service
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inlineCode: |
            -- Lightweight Lua JWT claim extraction without external modules.
            -- Istio's distroless sidecar image does not ship cjson/rapidjson, so we
            -- avoid require() entirely and use simple pattern matching on the
            -- RequestAuthentication-provided x-jwt-payload header (JSON string).

            local oauth_host = "oauth2.cat-herding.net"
            local client_id = "profile-service"

            local function urlencode(str)
              return (str:gsub("([^%w_.%-~])", function(c)
                return string.format("%%%02X", string.byte(c))
              end))
            end

            -- Very small JSON helper: works for flat string claims and simple string arrays.
            local function parse_claim(payload, key)
              if payload == nil then
                return nil
              end

              -- Remove whitespace to make pattern matching simpler
              local compact = payload:gsub("%s+", "")

              -- Match string value: "key":"value"
              local value = compact:match('"' .. key .. '":"(.-)"')
              if value ~= nil then
                return value
              end

              -- Match simple string array: "key":["v1","v2"]
              local array_body = compact:match('"' .. key .. '":%[(.-)%]')
              if array_body ~= nil then
                local parts = {}
                for v in array_body:gmatch('"(.-)"') do
                  table.insert(parts, v)
                end
                return parts
              end

              return nil
            end

            local function to_header_value(v)
              if v == nil then
                return nil
              end
              if type(v) == "table" then
                return table.concat(v, ",")
              end
              return tostring(v)
            end

            function envoy_on_request(handle)
              local payload_json = handle:headers():get("x-jwt-payload")
              local path_with_query = handle:headers():get(":path") or "/"
              local path_only = path_with_query:match("^[^?]+") or "/"

              -- Allow OAuth2 callback, actuator, and public API endpoints to reach the app without JWTs
              if path_only:find("^/login/oauth2/code/") == 1
                  or path_only:find("^/actuator") == 1
                  or path_only == "/favicon.ico"
                  or path_only == "/api/status"
                  or path_only:find("^/public/") == 1 then
                return
              end

              -- Redirect unauthenticated callers to OAuth2 authorize endpoint
              if payload_json == nil then
                local authority = handle:headers():get(":authority") or "profile.cat-herding.net"
                local redirect_uri = "https://" .. authority .. path_with_query
                local location = "https://" .. oauth_host .. "/oauth2/authorize" ..
                  "?response_type=code" ..
                  "&client_id=" .. client_id ..
                  "&scope=" .. urlencode("openid profile") ..
                  "&redirect_uri=" .. urlencode(redirect_uri)

                handle:respond({
                  [":status"] = "302",
                  ["Location"] = location,
                  ["Cache-Control"] = "no-store",
                  ["Pragma"] = "no-cache"
                }, "")
                return
              end

              local function add_claim(header, claim_key)
                local v = to_header_value(parse_claim(payload_json, claim_key))
                if v ~= nil then
                  handle:headers():add(header, v)
                end
              end

              add_claim("x-jwt-sub", "sub")
              add_claim("x-jwt-username", "preferred_username")
              add_claim("x-jwt-email", "email")
              add_claim("x-jwt-name", "name")
              add_claim("x-jwt-scope", "scope")

              -- Remove the raw payload header so it is not forwarded downstream
              handle:headers():remove("x-jwt-payload")
            end