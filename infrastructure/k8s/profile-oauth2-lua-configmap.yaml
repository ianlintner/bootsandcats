apiVersion: v1
kind: ConfigMap
metadata:
  name: profile-oauth2-lua-script
  namespace: default
  labels:
    app.kubernetes.io/managed-by: kustomize
    project: bootsandcats
data:
  oauth2-exchange.lua: |
    --[[
      OAuth2 Authorization Code Exchange Filter for Profile Service
      
      Flow:
      1. Check for session cookie with access token
      2. If token in cookie, add Authorization header for Istio JWT validation  
      3. If no token and ?code= present, exchange code for token via httpCall
      4. If no token and no code, redirect to OAuth2 authorize
      5. Store token in HttpOnly cookie for subsequent requests
    ]]--

    local OAUTH_HOST = "oauth2.cat-herding.net"
    local CLIENT_ID = "profile-service"
    local COOKIE_NAME = "_profile_session"
    local COOKIE_MAX_AGE = 900  -- 15 minutes

    -- Client secret for token exchange
    -- NOTE: For production, use external secret management (SDS, sealed secrets, etc.)
    local CLIENT_SECRET = "1b3IMYigvWui1Ut1uN5RgxkoguBuG+UrQOY32TBfeuA="

    -- URL encode helper
    local function urlencode(str)
      if str == nil then return "" end
      return (str:gsub("([^%w_.%-~])", function(c)
        return string.format("%%%02X", string.byte(c))
      end))
    end

    -- URL decode helper
    local function urldecode(str)
      if str == nil then return "" end
      return (str:gsub("%%(%x%x)", function(hex)
        return string.char(tonumber(hex, 16))
      end):gsub("+", " "))
    end

    -- Parse query string into table
    local function parse_query(query)
      local params = {}
      if query == nil or query == "" then return params end
      for pair in query:gmatch("[^&]+") do
        local key, value = pair:match("([^=]+)=?(.*)")
        if key then
          params[urldecode(key)] = urldecode(value or "")
        end
      end
      return params
    end

    -- Get cookie value by name
    local function get_cookie(cookie_header, name)
      if cookie_header == nil then return nil end
      for cookie in cookie_header:gmatch("[^;]+") do
        local trimmed = cookie:match("^%s*(.-)%s*$")
        local k, v = trimmed:match("([^=]+)=(.*)")
        if k and k == name then
          return v
        end
      end
      return nil
    end

    -- Extract JSON string value (simple pattern matching, no cjson needed)
    local function json_get_string(json_str, key)
      if json_str == nil then return nil end
      local pattern = '"' .. key .. '"%s*:%s*"([^"]*)"'
      return json_str:match(pattern)
    end

    -- Check if path should bypass authentication
    local function is_public_path(path)
      return path:find("^/actuator") == 1
          or path == "/favicon.ico"
          or path:find("^/api/status") == 1
          or path:find("^/public/") == 1
          or path:find("^/css/") == 1
          or path:find("^/js/") == 1
          or path:find("^/images/") == 1
          or path:find("^/webjars/") == 1
          or path:find("^/swagger") == 1
          or path:find("^/openapi") == 1
    end

    function envoy_on_request(request_handle)
      local headers = request_handle:headers()
      local path_with_query = headers:get(":path") or "/"
      local path_only = path_with_query:match("^([^?]+)") or "/"
      local query_string = path_with_query:match("%?(.+)$")
      local authority = headers:get(":authority") or "profile.cat-herding.net"
      local cookie_header = headers:get("cookie")

      -- Skip auth for public paths
      if is_public_path(path_only) then
        return
      end

      -- Check for existing session token in cookie
      local session_token = get_cookie(cookie_header, COOKIE_NAME)
      
      if session_token ~= nil and session_token ~= "" then
        -- Have token - set Authorization header for Istio JWT validation
        local existing_auth = headers:get("authorization")
        if existing_auth == nil then
          headers:add("Authorization", "Bearer " .. session_token)
        end
        return
      end

      -- Parse query params
      local params = parse_query(query_string)
      local auth_code = params["code"]
      local state = params["state"]

      -- If we have an authorization code, exchange it for tokens
      if auth_code ~= nil and auth_code ~= "" then
        request_handle:logInfo("OAuth2: Received authorization code, initiating token exchange")
        
        -- Build token request body
        local redirect_uri = "https://" .. authority .. "/"
        local token_body = "grant_type=authorization_code" ..
          "&code=" .. urlencode(auth_code) ..
          "&redirect_uri=" .. urlencode(redirect_uri) ..
          "&client_id=" .. urlencode(CLIENT_ID) ..
          "&client_secret=" .. urlencode(CLIENT_SECRET)

        local call_headers = {
          [":method"] = "POST",
          [":path"] = "/oauth2/token",
          [":authority"] = "oauth2-server.default.svc.cluster.local",
          ["content-type"] = "application/x-www-form-urlencoded",
          ["accept"] = "application/json"
        }

        -- Make HTTP call to token endpoint
        local resp_headers, resp_body = request_handle:httpCall(
          "oauth2_token_cluster",
          call_headers,
          token_body,
          5000,
          false
        )

        if resp_headers then
          local status = resp_headers[":status"]
          request_handle:logInfo("OAuth2: Token endpoint responded with status " .. (status or "nil"))
          
          if status == "200" and resp_body then
            local access_token = json_get_string(resp_body, "access_token")
            
            if access_token and access_token ~= "" then
              -- Success! Set cookie and redirect to clean URL
              local clean_path = "/"
              if state and state ~= "" then
                clean_path = urldecode(state)
              end
              
              local cookie = COOKIE_NAME .. "=" .. access_token ..
                "; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=" .. COOKIE_MAX_AGE

              request_handle:logInfo("OAuth2: Token exchange successful, setting session cookie")
              
              request_handle:respond(
                {
                  [":status"] = "302",
                  ["location"] = "https://" .. authority .. clean_path,
                  ["set-cookie"] = cookie,
                  ["cache-control"] = "no-store",
                  ["pragma"] = "no-cache"
                },
                ""
              )
              return
            else
              request_handle:logWarn("OAuth2: No access_token in response body")
            end
          else
            request_handle:logWarn("OAuth2: Token exchange failed - status: " .. (status or "nil") .. ", body: " .. (resp_body or "nil"))
          end
        else
          request_handle:logErr("OAuth2: httpCall to token endpoint failed - no response")
        end

        -- Token exchange failed - return error page
        request_handle:respond(
          {
            [":status"] = "401",
            ["content-type"] = "text/html; charset=utf-8",
            ["cache-control"] = "no-store"
          },
          "<!DOCTYPE html><html><head><title>Authentication Failed</title></head>" ..
          "<body style='font-family: system-ui; padding: 2rem; text-align: center;'>" ..
          "<h1>Authentication Failed</h1>" ..
          "<p>Could not complete the login process.</p>" ..
          "<p><a href='/'>Try again</a></p></body></html>"
        )
        return
      end

      -- No token and no code - redirect to OAuth2 authorize endpoint
      local redirect_uri = "https://" .. authority .. "/"
      local state_param = urlencode(path_with_query)
      
      local authorize_url = "https://" .. OAUTH_HOST .. "/oauth2/authorize" ..
        "?response_type=code" ..
        "&client_id=" .. urlencode(CLIENT_ID) ..
        "&scope=" .. urlencode("openid profile email") ..
        "&redirect_uri=" .. urlencode(redirect_uri) ..
        "&state=" .. state_param

      request_handle:logInfo("OAuth2: No session, redirecting to authorize endpoint")
      
      request_handle:respond(
        {
          [":status"] = "302",
          ["location"] = authorize_url,
          ["cache-control"] = "no-store",
          ["pragma"] = "no-cache"
        },
        ""
      )
    end
