apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: secure-subdomain-oauth2-exchange
  namespace: aks-istio-ingress
  labels:
    app.kubernetes.io/managed-by: kustomize
    project: bootsandcats
spec:
  # Apply to the ingress gateway, not individual workloads
  workloadSelector:
    labels:
      istio: aks-istio-ingressgateway-external
  configPatches:
  # Enforce login for *.cat-herding.net via oauth2-proxy using the auth_request pattern.
  #
  # Design notes:
  # - We call oauth2-proxy's `/_oauth2/auth` endpoint for each request.
  # - oauth2-proxy returns 202 (authorized) or 401 (unauthorized).
  # - On 401 we redirect the browser to `/_oauth2/start?rd=<original_url>`.
  # - oauth2-proxy holds the client secret; Envoy no longer reads client secrets via SDS.
  - applyTo: HTTP_FILTER
    match:
      context: GATEWAY
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inline_code: |
            local OAUTH2_PROXY_CLUSTER = "outbound|4180||oauth2-proxy.aks-istio-ingress.svc.cluster.local"
            local OAUTH2_PREFIX = "/_oauth2"
            local OAUTH2_AUTH_PATH = OAUTH2_PREFIX .. "/auth"

            local function starts_with(str, prefix)
              return str ~= nil and string.sub(str, 1, string.len(prefix)) == prefix
            end

            local function url_encode(str)
              if str == nil then
                return ""
              end
              -- RFC 3986-ish percent encoding.
              return (string.gsub(str, "([^%w%-_%.~])", function(c)
                return string.format("%%%02X", string.byte(c))
              end))
            end

            local function should_skip(headers)
              local authority = headers:get(":authority") or ""
              local path = headers:get(":path") or ""

              -- Don't protect the authorization server host itself.
              if authority == "oauth2.cat-herding.net" then
                return true
              end

              -- Don't protect oauth2-proxy endpoints.
              if starts_with(path, OAUTH2_PREFIX .. "/") then
                return true
              end

              -- Basic health/ops endpoints.
              if starts_with(path, "/actuator") or path == "/health" or path == "/healthz" or path == "/ready" then
                return true
              end

              return false
            end

            function envoy_on_request(request_handle)
              local headers = request_handle:headers()
              if should_skip(headers) then
                return
              end

              local authority = headers:get(":authority") or ""
              local path = headers:get(":path") or "/"
              local proto = headers:get("x-forwarded-proto") or "https"
              local cookie = headers:get("cookie")

              local original_url = proto .. "://" .. authority .. path

              local auth_headers = {
                [":method"] = "GET",
                [":path"] = OAUTH2_AUTH_PATH,
                -- oauth2-proxy expects the original host in Host/:authority.
                [":authority"] = authority,
                ["host"] = authority,
                ["x-forwarded-proto"] = proto,
                ["x-forwarded-host"] = authority,
                ["x-forwarded-uri"] = path,
                ["x-auth-request-redirect"] = original_url,
              }

              if cookie ~= nil then
                auth_headers["cookie"] = cookie
              end

              local resp_headers, _ = request_handle:httpCall(
                OAUTH2_PROXY_CLUSTER,
                auth_headers,
                nil,
                5000)

              local status = resp_headers[":status"] or ""
              if status == "202" then
                -- On success, copy selected auth headers from oauth2-proxy into the upstream request.
                local authorization = resp_headers["authorization"]
                if authorization ~= nil then
                  headers:replace("authorization", authorization)
                end

                local x_user = resp_headers["x-auth-request-user"]
                if x_user ~= nil then
                  headers:replace("x-auth-request-user", x_user)
                end

                local x_email = resp_headers["x-auth-request-email"]
                if x_email ~= nil then
                  headers:replace("x-auth-request-email", x_email)
                end

                local x_preferred = resp_headers["x-auth-request-preferred-username"]
                if x_preferred ~= nil then
                  headers:replace("x-auth-request-preferred-username", x_preferred)
                end

                return
              end

              -- Unauthorized -> redirect to oauth2-proxy sign-in.
              local rd = url_encode(original_url)
              local location = proto .. "://" .. authority .. OAUTH2_PREFIX .. "/start?rd=" .. rd
              request_handle:respond({
                [":status"] = "302",
                ["location"] = location,
              }, "")
            end

