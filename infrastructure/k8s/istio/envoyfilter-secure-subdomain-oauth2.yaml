apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: secure-subdomain-oauth2-exchange
  namespace: aks-istio-ingress
  labels:
    app.kubernetes.io/managed-by: kustomize
    project: bootsandcats
spec:
  # Apply to the ingress gateway, not individual workloads
  workloadSelector:
    labels:
      istio: aks-istio-ingressgateway-external
  configPatches:
  # Enforce login for *.cat-herding.net via oauth2-proxy using the auth_request pattern.
  #
  # Design notes:
  # - We call oauth2-proxy's `/_oauth2/auth` endpoint for each request.
  # - oauth2-proxy returns 202 (authorized) or 401 (unauthorized).
  # - On 401 we redirect the browser to `/_oauth2/start?rd=<original_url>`.
  # - oauth2-proxy holds the client secret; Envoy no longer reads client secrets via SDS.
  - applyTo: HTTP_FILTER
    match:
      context: GATEWAY
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inline_code: |
            local OAUTH2_PROXY_CLUSTER = "outbound|4180||oauth2-proxy.aks-istio-ingress.svc.cluster.local"
            local OAUTH2_PREFIX = "/_oauth2"
            local OAUTH2_AUTH_PATH = OAUTH2_PREFIX .. "/auth"
            local METADATA_NAMESPACE = "oauth2_proxy_auth"
            local METADATA_SET_COOKIE_KEY = "set-cookie"

            local function starts_with(str, prefix)
              return str ~= nil and string.sub(str, 1, string.len(prefix)) == prefix
            end

            local function url_encode(str)
              if str == nil then
                return ""
              end
              -- RFC 3986-ish percent encoding.
              return (string.gsub(str, "([^%w%-_%.~])", function(c)
                return string.format("%%%02X", string.byte(c))
              end))
            end

            local function get_any(headers, keys)
              for _, k in ipairs(keys) do
                local v = headers[k]
                if v ~= nil and v ~= "" then
                  return v
                end
              end
              return nil
            end

            local function should_skip(headers)
              local authority = headers:get(":authority") or ""
              local path = headers:get(":path") or ""

              -- Don't protect the authorization server host itself.
              if authority == "oauth2.cat-herding.net" then
                return true
              end

              -- Don't protect oauth2-proxy endpoints.
              if starts_with(path, OAUTH2_PREFIX .. "/") then
                return true
              end

              -- Basic health/ops endpoints.
              if starts_with(path, "/actuator") or path == "/health" or path == "/healthz" or path == "/ready" then
                return true
              end

              return false
            end

            function envoy_on_request(request_handle)
              -- IMPORTANT: do not hold on to the request headers handle across httpCall().
              -- Envoy's Lua filter yields during httpCall, and using previously captured
              -- HeaderMap objects after that can trigger "object used outside of proper scope".
              local req_headers = request_handle:headers()
              if should_skip(req_headers) then
                return
              end

              local authority = req_headers:get(":authority") or ""
              local path = req_headers:get(":path") or "/"
              local proto = req_headers:get(":scheme") or req_headers:get("x-forwarded-proto") or "https"
              local cookie = req_headers:get("cookie")
              local inbound_authorization = req_headers:get("authorization")

              local original_url = proto .. "://" .. authority .. path

              local auth_headers = {
                [":method"] = "GET",
                [":path"] = OAUTH2_AUTH_PATH,
                -- oauth2-proxy expects the original host in Host/:authority.
                [":authority"] = authority,
                ["host"] = authority,
                ["x-forwarded-proto"] = proto,
                ["x-forwarded-host"] = authority,
                ["x-forwarded-uri"] = path,
                ["x-auth-request-redirect"] = original_url,
              }

              if cookie ~= nil then
                auth_headers["cookie"] = cookie
              end

              if inbound_authorization ~= nil then
                auth_headers["authorization"] = inbound_authorization
              end

              local resp_headers, _ = request_handle:httpCall(
                OAUTH2_PROXY_CLUSTER,
                auth_headers,
                nil,
                5000)

              if resp_headers == nil then
                request_handle:respond({
                  [":status"] = "503",
                }, "")
                return
              end

              local status = resp_headers[":status"] or ""
              if status == "202" then
                -- Re-acquire the request headers handle after httpCall().
                local headers = request_handle:headers()

                -- If oauth2-proxy refreshed the session cookie during /auth, forward it.
                local set_cookie = resp_headers["set-cookie"] or resp_headers["Set-Cookie"]
                if set_cookie ~= nil then
                  request_handle:streamInfo():dynamicMetadata():set(METADATA_NAMESPACE, METADATA_SET_COOKIE_KEY, set_cookie)
                end

                -- On success, copy selected auth headers from oauth2-proxy into the upstream request.
                -- IMPORTANT: the jwt_authn filter runs after this Lua filter and will populate
                -- x-jwt-* headers (including x-jwt-sub) only if it sees a Bearer token.
                --
                -- For auth_request-style deployments, oauth2-proxy typically returns the access token
                -- in X-Auth-Request-Access-Token rather than in an Authorization header.
                local authorization = get_any(resp_headers, {
                  "authorization",
                  "Authorization",
                })
                local access_token = get_any(resp_headers, {
                  "x-auth-request-access-token",
                  "X-Auth-Request-Access-Token",
                })

                if authorization ~= nil and authorization ~= "" then
                  headers:replace("authorization", authorization)
                elseif access_token ~= nil and access_token ~= "" then
                  headers:replace("authorization", "Bearer " .. access_token)
                  headers:replace("x-auth-request-access-token", access_token)
                end

                local x_user = get_any(resp_headers, {
                  "x-auth-request-user",
                  "X-Auth-Request-User",
                })
                if x_user ~= nil then
                  headers:replace("x-auth-request-user", x_user)
                end

                local x_email = get_any(resp_headers, {
                  "x-auth-request-email",
                  "X-Auth-Request-Email",
                })
                if x_email ~= nil then
                  headers:replace("x-auth-request-email", x_email)
                end

                -- Back-compat: many upstream services expect JWT-derived headers set by the gateway.
                -- Normally the jwt_authn filter maps claims -> x-jwt-* headers, but that depends on
                -- a Bearer token being present and validated.
                --
                -- To avoid hard failures (e.g. profile-service requires x-jwt-sub), synthesize
                -- x-jwt-sub from oauth2-proxy's auth response when available.
                --
                -- NOTE: In our oauth2-proxy deployment we set --oidc-email-claim=sub, so the
                -- x-auth-request-email header is stable and aligns to an OIDC subject identifier.
                if x_email ~= nil and x_email ~= "" then
                  headers:replace("x-jwt-sub", x_email)
                elseif x_user ~= nil and x_user ~= "" then
                  headers:replace("x-jwt-sub", x_user)
                end

                local x_preferred = get_any(resp_headers, {
                  "x-auth-request-preferred-username",
                  "X-Auth-Request-Preferred-Username",
                })
                if x_preferred ~= nil then
                  headers:replace("x-auth-request-preferred-username", x_preferred)
                end

                return
              end

              if status == "401" then
                -- Unauthorized -> redirect to oauth2-proxy sign-in.
                local rd = url_encode(original_url)
                local location = proto .. "://" .. authority .. OAUTH2_PREFIX .. "/start?rd=" .. rd
                request_handle:respond({
                  [":status"] = "302",
                  ["location"] = location,
                }, "")
                return
              end

              -- For anything else (e.g., 403, 5xx), return the status from oauth2-proxy.
              local www_authenticate = resp_headers["www-authenticate"]
              local out_headers = {
                [":status"] = status,
              }
              if www_authenticate ~= nil then
                out_headers["www-authenticate"] = www_authenticate
              end

              request_handle:respond(out_headers, "")
            end

            function envoy_on_response(response_handle)
              local md = response_handle:streamInfo():dynamicMetadata():get(METADATA_NAMESPACE)
              if md == nil then
                return
              end

              local set_cookie = md[METADATA_SET_COOKIE_KEY]
              if set_cookie ~= nil then
                response_handle:headers():add("set-cookie", set_cookie)
              end
            end

