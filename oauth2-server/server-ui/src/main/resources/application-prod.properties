# Production Configuration

# Database Configuration (PostgreSQL for production)
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://localhost:5432/oauth2db}
spring.datasource.username=${DATABASE_USERNAME:postgres}
spring.datasource.password=${DATABASE_PASSWORD:postgres}
spring.datasource.driverClassName=org.postgresql.Driver
# Hibernate auto-detects PostgreSQL dialect - no need to specify explicitly
spring.jpa.hibernate.ddl-auto=validate

# HikariCP connection pool settings for production
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.validation-timeout=5000
spring.datasource.hikari.leak-detection-threshold=60000

# JPA/Hibernate settings for production
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.properties.hibernate.jdbc.time_zone=UTC
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# Flyway for schema migrations
spring.flyway.enabled=true
spring.flyway.locations=classpath*:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=0
spring.flyway.validate-on-migrate=true
spring.flyway.placeholders.profile_service_client_secret={noop}${OAUTH2_DEMO_CLIENT_SECRET:demo-secret}

# Disable Spring Boot Admin client in production (no admin server in prod)
spring.boot.admin.client.enabled=false

# Disable H2 Console in production
spring.h2.console.enabled=false

# Security Configuration
server.servlet.session.cookie.secure=true
# Use lax instead of strict to allow OAuth2 redirects from federated identity providers
server.servlet.session.cookie.same-site=lax
server.servlet.session.timeout=15m

# Spring Session - Redis for distributed sessions in K8s
spring.session.store-type=${SESSION_STORE_TYPE:redis}

# Redis Configuration for session storage
spring.data.redis.host=${REDIS_HOST:redis}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.ssl.enabled=${REDIS_SSL_ENABLED:false}
spring.data.redis.timeout=2000ms
spring.data.redis.connect-timeout=5000ms
spring.data.redis.lettuce.pool.enabled=true
spring.data.redis.lettuce.pool.max-active=16
spring.data.redis.lettuce.pool.max-idle=8
spring.data.redis.lettuce.pool.min-idle=4
spring.data.redis.lettuce.pool.max-wait=2000ms

# SSL handled by load balancer/ingress in production
server.ssl.enabled=${SERVER_SSL_ENABLED:false}
# server.ssl.key-store=classpath:keystore.p12
# server.ssl.key-store-password=${SSL_KEYSTORE_PASSWORD}
# server.ssl.key-store-type=PKCS12
# server.ssl.key-alias=oauth2

# Actuator Security
management.endpoints.web.exposure.include=health,info,prometheus
management.endpoint.health.show-details=never

# OpenTelemetry Configuration
otel.exporter.otlp.endpoint=${OTEL_EXPORTER_ENDPOINT:http://localhost:4317}
otel.service.name=oauth2-authorization-server
# Note: resource attributes should be set via environment variables or separate properties
# otel.resource.attributes.service.namespace=production
# otel.resource.attributes.deployment.environment=prod

# Tracing (Micrometer Tracing -> OTLP)
management.tracing.enabled=true
management.tracing.sampling.probability=${TRACING_SAMPLING_PROBABILITY:0.05}
management.otlp.tracing.endpoint=${OTEL_EXPORTER_OTLP_TRACES_ENDPOINT:http://otel-collector:4318/v1/traces}

# Logging
logging.level.org.springframework.security=WARN
logging.level.org.springframework.security.oauth2=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.com.bootsandcats=INFO

# OAuth2 Configuration (MUST be set via environment variables in production)
oauth2.issuer-url=${OAUTH2_ISSUER_URL}
oauth2.demo-client-secret=${OAUTH2_DEMO_CLIENT_SECRET}
oauth2.m2m-client-secret=${OAUTH2_M2M_CLIENT_SECRET}
oauth2.demo-user-password=${OAUTH2_DEMO_USER_PASSWORD}
oauth2.admin-user-password=${OAUTH2_ADMIN_USER_PASSWORD}

# Azure Key Vault Configuration for JWK/Signing Keys
azure.keyvault.enabled=${AZURE_KEYVAULT_ENABLED:false}
azure.keyvault.vault-uri=${AZURE_KEYVAULT_VAULT_URI:}
azure.keyvault.jwk-secret-name=${AZURE_KEYVAULT_JWK_SECRET_NAME:oauth2-jwk}
azure.keyvault.cache-ttl=${AZURE_KEYVAULT_CACHE_TTL:PT10M}

server.error.include-message=always
